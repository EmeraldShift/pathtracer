#include "../scene/scene.h"
#include <cmath>
#include <glm/gtx/io.hpp>

using namespace std;

TrimeshFace::TrimeshFace(const Material &mat, Trimesh *parent, int a, int b, int c)
        : Geometry(mat) {
    this->parent = parent;
    ids[0] = a;
    ids[1] = b;
    ids[2] = c;

    // Compute the face normal here, not on the fly
    glm::dvec3 a_coords = parent->vertices[a];
    glm::dvec3 b_coords = parent->vertices[b];
    glm::dvec3 c_coords = parent->vertices[c];

    glm::dvec3 vab = (b_coords - a_coords);
    glm::dvec3 vac = (c_coords - a_coords);
    glm::dvec3 vcb = (b_coords - c_coords);

    if (glm::length(vab) == 0.0 || glm::length(vac) == 0.0 ||
        glm::length(vcb) == 0.0)
        degen = true;
    else {
        degen = false;
        normal = glm::normalize(glm::cross(vab, vac));

        auto inv = glm::inverse(glm::dmat3(vab, vac, normal));
        uInv = glm::dvec3(inv[0][0], inv[1][0], inv[2][0]);
        vInv = glm::dvec3(inv[0][1], inv[1][1], inv[2][1]);
        nInv = glm::dvec3(inv[0][2], inv[1][2], inv[2][2]);
    }
    bounds = computeLocalBoundingBox();
}

BoundingBox TrimeshFace::computeLocalBoundingBox() {
    BoundingBox bb;
    bb.setMax(glm::max(parent->vertices[ids[0]],
                       parent->vertices[ids[1]]));
    bb.setMin(glm::min(parent->vertices[ids[0]],
                       parent->vertices[ids[1]]));

    bb.setMax(glm::max(parent->vertices[ids[2]],
                       bb.getMax()));
    bb.setMin(glm::min(parent->vertices[ids[2]],
                       bb.getMin()));
    return bb;
}

Trimesh::~Trimesh() {
    for (auto f : faces)
        delete f;
}

// must add vertices, normals, and materials IN ORDER
void Trimesh::addVertex(const glm::dvec3 &v) {
    vertices.emplace_back(v);
}

void Trimesh::addMaterial(const Material &m) {
    materials.emplace_back(m);
}

void Trimesh::addNormal(const glm::dvec3 &n) {
    normals.emplace_back(n);
}

// Returns false if the vertices a,b,c don't all exist
bool Trimesh::addFace(int a, int b, int c) {
    int vcnt = vertices.size();

    if (a >= vcnt || b >= vcnt || c >= vcnt)
        return false;

    auto newFace = new TrimeshFace(material, this, a, b, c);
    if (!newFace->degen)
        faces.push_back(newFace);
    else
        delete newFace;

    // Don't add faces to the scene's object list so we can cull by bounding
    // box
    return true;
}

// Check to make sure that if we have per-vertex materials or normals
// they are the right number.
const char *Trimesh::doubleCheck() {
    if (!materials.empty() && materials.size() != vertices.size())
        return "Bad Trimesh: Wrong number of materials.";
    if (!normals.empty() && normals.size() != vertices.size())
        return "Bad Trimesh: Wrong number of normals.";

    return nullptr;
}

// Once all the verts and faces are loaded, per vertex normals can be
// generated by averaging the normals of the neighboring faces.
void Trimesh::generateNormals() {
    int cnt = vertices.size();
    normals.resize(cnt);
    std::vector<int> numFaces(cnt, 0);

    for (auto face : faces) {
        glm::dvec3 faceNormal = face->getNormal();

        for (int i = 0; i < 3; ++i) {
            normals[(*face)[i]] += faceNormal;
            ++numFaces[(*face)[i]];
        }
    }

    for (int i = 0; i < cnt; ++i) {
        if (numFaces[i])
            normals[i] /= numFaces[i];
    }
}

bool TrimeshFace::intersect(ray &r, isect &i) const {
    auto p = r.getPosition() - parent->vertices[ids[0]];
    auto d = r.getDirection();
    auto p_z = glm::dot(nInv, p);
    auto d_z = glm::dot(nInv, d);
    if (p_z < 0 == d_z < 0)
        return false;

    auto t = -p_z / d_z;
    if (t > i.getT())
        return false;

    auto hit = p + t * d;
    double u = glm::dot(uInv, hit); // p1
    double v = glm::dot(vInv, hit); // p2;
    double w = 1 - u - v; // p0

    if (u < 0 || u > 1 || v < 0 || v > 1 || u + v > 1)
        return false;

    i.setT(t);
    i.setUVCoordinates(glm::dvec2(u, v));
    if (parent->materials.empty()) {
        i.setMaterial(this->getMaterial());
    } else {
        Material m0 = parent->materials[ids[0]];
        Material m1 = parent->materials[ids[1]];
        Material m2 = parent->materials[ids[2]];
        m0 = w * m0;
        m1 = u * m1;
        m2 = v * m2;
        m0 += m1;
        m0 += m2;
        i.setMaterial(m0);
    }
    if (parent->normals.empty())
        i.setN(normal);
    else
        i.setN(glm::normalize(u * parent->normals[ids[1]] + v * parent->normals[ids[2]] + w * parent->normals[ids[0]]));
    return true;
}
